{
  "hash": "bd826cc8dcb96f7540b3c43d5f4478c0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Density map of wolf in the Iberian Peninsula\"\ndescription: \"Create a density map of any species using GBIF data and ggplot2\"\ndate: \"2024-07-14\"\ncategories: [ggplot2, R, spatial]\nimage: \"image.png\"\nbibliography: references.bib\nexecute: \n  warning: false\neditor_options: \n  chunk_output_type: console\n---\n\n{{< video https://www.youtube.com/watch?v=GCyhbrzowtM >}}\n\n\n\n\n## Introduction\n\nToday we will see how to create a map of the density of wolves' observations in the Iberian Peninsula during the last decade (2014-2023).\n\nWe will use data from the Global Biodiversity Information Facility (GBIF) through the `{geodata}` package, and we will create a map of the Kernel Density of the observations using `{ggplot2}`.\n\n## Loading packages\n\nWe will use the following packages:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Load pacman\nlibrary(pacman)\n\n## Load rest of the packages\np_load(\n  geodata, ggnewscale, giscoR, rayshader, sf, terra, tidyterra, tidyverse\n)\n```\n:::\n\n\n\n-   `{geodata}` [@geodata]: we will use it to download data from the GBIF database, and the Digital Elevation Model (DEM).\n\n-   `{ggnewscale}` [@ggnewscale]: to create a new scale in {ggplot2} of the same aesthetic.\n\n-   `{giscoR}` [@giscoR]: to download the boundaries of the study area.\n\n-   `{rayshader}` [@rayshader]: to create a 3D map.\n\n-   `{sf}` [@sf]: to manipulate vectorial data.\n\n-   `{terra}` [@terra]: to manipulate raster data.\n\n-   `{tidyterra}` [@tidyterra]: to use a nice colour palette for the DEM.\n\n-   `{tidyverse}` [@tidyverse]: to manipulate data in general.\n\n## Load the data\n\nIn this exercise we need to download three sources of data:\n\n-   Study area\n\n-   Wolf data\n\n-   Digital Elevation Model\n\n### Study area\n\nThe study area for this exercise is the Iberian Peninsula, which includes the main land of Spain and Portugal without islands. To extract this area, we need first to get the boundaries of Spain and Portugal, eliminate the islands, and combine both countries. So, one step at a time. We start downloading the country of Portugal, and casting the MULTIPOLYGON to POLYGON:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Get Portugal\nportugal_sf <- gisco_get_countries(\n  resolution = \"01\",\n  country    = \"Portugal\"\n) |> \n  st_cast(\"POLYGON\")\n\n## Visualize\nplot(st_geometry(portugal_sf))\n```\n\n::: {.cell-output-display}\n![Country of Portugal](index_files/figure-html/fig-portugal-1.png){#fig-portugal width=672}\n:::\n:::\n\n\n\nTo filter the main land, we can calculate the area of each polygon, and slice the polygon with the maximum value of area:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Get main land\nportugal_sf <- portugal_sf |> \n  mutate(\n    area = st_area(portugal_sf)\n  ) |> \n  slice_max(area)\n\n## Visualize\nplot(st_geometry(portugal_sf))\n```\n\n::: {.cell-output-display}\n![Main land of Portugal](index_files/figure-html/fig-portugal-mainland-1.png){#fig-portugal-mainland width=672}\n:::\n:::\n\n\n\nNow, we can do the same for Spain:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Get Spain\nspain_sf <- gisco_get_countries(\n  resolution = \"01\",\n  country    = \"Spain\"\n) |> \n  st_cast(\"POLYGON\")\n\n## Get main land\nspain_sf <- spain_sf |> \n  mutate(\n    area = st_area(spain_sf)\n  ) |> \n  slice_max(area)\n\n## Visualize\nplot(st_geometry(spain_sf))\n```\n\n::: {.cell-output-display}\n![Main land of Spain](index_files/figure-html/fig-spain-1.png){#fig-spain width=672}\n:::\n:::\n\n\n\nUp to this point, we have two different {sf} objects with the main land of Portugal [@fig-portugal-mainland] and Spain [@fig-spain]. The final step, is to combine them to form only one polygon:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Make union\niberia_sf <- st_union(\n  spain_sf,\n  portugal_sf\n) |> \n  st_transform(25830)\n\n## Visualize\nplot(st_geometry(iberia_sf))\n```\n\n::: {.cell-output-display}\n![Study area](index_files/figure-html/fig-iberia-1.png){#fig-iberia width=672}\n:::\n:::\n\n\n\nNote that we also transformed the Coordinates Reference System to a projected system (EPSG 25830).\n\n### Wolf data\n\nIn this exercise, we will study the distribution of the gray wolf (*Canis lupus*; @fig-wolf) in the Iberian Peninsula:\n\n![Gray wolf (Source: wikipedia)](figs/wolf-picture.jpg){#fig-wolf fig-align=\"center\"}\n\nAs a proxy of the distribution, we will use data from GBIF for the period 2013-2024. This database contains information about observations of any species in the world. We will use the `sp_occurrence()` function from the `{geodata}` package, and we will add two arguments to specify the countries (ES for Spain, PT for Portugal) and the period (2014-2023).\n\n::: callout-tip\nTo specify a period, separate two years by a comma.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Download wolf data\n## - Years: 2014-2023\nwolf_lst <- map(\n  .x = c(\"ES\", \"PT\"),\n  .f = \\(x) sp_occurrence(\n    genus   = \"Canis\",\n    species = \"lupus\",\n    args    = c(\n      paste0(\"country=\", x),\n      \"year=2014,2023\"\n    )\n  )\n)\n```\n:::\n\n\n\nNote that we use the `purrr::map()` function to iterate over two elements (ES and PO) which are used in the *country* argument.\n\n### Elevation\n\nThe elevation data can be downloaded using the `{geodata}` package. We use the `elevation_global()` function to download the DEM for all the world at 0.5 minutes of a degree spatial resolution. Immediately, we use the `terra::crop()` function to crop and mask only the Iberian Peninsula (note that the data must be transformed before cropping to the same CRS), and then we transform the CRS to the same projected CRS as the Iberian Peninsula.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Download global DEM, crop it to Iberia, and project it\ndem_sr <- elevation_global(res = .5, path = tempdir()) |> \n  crop(\n    st_transform(iberia_sf, 4326),\n    mask = TRUE\n  ) |> \n  project(\"EPSG:25830\")\n## Print DEM\nprint(dem_sr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \ndimensions  : 1142, 1492, 1  (nrow, ncol, nlyr)\nresolution  : 774.7848, 774.7848  (x, y)\nextent      : -86157.96, 1069821, 3984505, 4869310  (xmin, xmax, ymin, ymax)\ncoord. ref. : ETRS89 / UTM zone 30N (EPSG:25830) \nsource(s)   : memory\nname        : wc2.1_30s_elev \nmin value   :      -4.587787 \nmax value   :    3250.524902 \n```\n\n\n:::\n:::\n\n\n\n## Prepare the data\n\nWe did already most of the data preparation steps previously, but there are a couple of things that I wanted to leave for this section.\n\n### Wolf data\n\nWe are using a projected CRS, but the coordinates data that we have in `wolf_lst` are in the WGS 84. Therefore, we need to transform this list to a `sf` object, transform the coordinates, and convert it back to a `tibble` with the coordinates in two columns. We could use the `geom_sf()`, but it might give us some issues with `rayshader` so we will use `geom_point()`.\n\nAnother thing to note is that we have data from the entire countries, but we want only from the Iberian Peninsula. In this sense, we can use `st_intersection()` to filter only the observations in the Iberian Peninsula.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Bind data, convert to sf, transform and select points within Iberia\nwolf_sf <- list_rbind(wolf_lst) |> \n  st_as_sf(\n    coords = c(\"lon\", \"lat\"),\n    crs    = 4326\n  ) |> \n  st_transform(25830) |> \n  st_intersection(iberia_sf) |> \n  select(country) \n\n## Visualize\nplot(st_geometry(wolf_sf))\nplot(st_geometry(iberia_sf), add = TRUE)\n```\n\n::: {.cell-output-display}\n![Gray wolf observations in the Iberian Peninsula](index_files/figure-html/fig-wolf-iberia-1.png){#fig-wolf-iberia width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Get data as tibble with coordinates\nwolf_tbl <- wolf_sf |> \n  mutate(\n    x = st_coordinates(wolf_sf)[, 1],\n    y = st_coordinates(wolf_sf)[, 2]\n  ) |> \n  as_tibble()\n\n## Data head\nhead(wolf_tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  country           geometry       x        y\n  <chr>          <POINT [m]>   <dbl>    <dbl>\n1 Spain   (602078.7 4335512) 602079. 4335512.\n2 Spain   (519809.4 4060480) 519809. 4060480.\n3 Spain   (193188.3 4115153) 193188. 4115153.\n4 Spain   (428693.5 4560619) 428693. 4560619.\n5 Spain   (279953.7 4815493) 279954. 4815493.\n6 Spain     (227613 4157558) 227613. 4157558.\n```\n\n\n:::\n:::\n\n\n\n### Elevation\n\nWe can use the `{tidyterra}` package to add the DEM to a {ggplot2} object. However, this would give us some problems when translating to the `{rayshader}` package. Because of this, we will use the `geom_raster()` function instead, and for that, we need a `tibble` with the coordinates and the values:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Convert to tibble \ndem_tbl <- dem_sr |>   \n  as_tibble(xy = TRUE) |>   \n  na.omit() |>    \n  rename(elevation = wc2.1_30s_elev)\n## Print head \nhead(dem_tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n        x        y elevation\n    <dbl>    <dbl>     <dbl>\n1 122647. 4858850.      12  \n2 107926. 4858075.      51  \n3 123421. 4858075.      91.7\n4 124196. 4858075.     111  \n5 105601. 4857300.     173. \n6 106376. 4857300.     166. \n```\n\n\n:::\n:::\n\n\n\nIn the previous code, we eliminated the NA values (pixels in the bounding box outside the boundaries of the Iberian Peninsula), and renamed the elevation value to a more intuitive name.\n\n## Visualization\n\n### 2D visualization\n\nWe will start creating a 2D visualization using `{ggplot2}`. You can see a better explanation of the code in the video, but one thing to note is that I am using the `new_scale_fill()` function because we have two different geometries (geom_raster and stat_density_2d) using the *fill* aesthetic. Therefore, if we want to modify them differently, we need to treat them in different `scale_fill_*` functions. The `{ggnewscale}` package help us to do this very easily, which is basically creating the first layer and its scale, then adding the `new_scale_*` function, and then adding the next geometry and its scale.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Create ggplot2 map\nmap <- wolf_tbl |> \n  ggplot() +\n  geom_raster(\n    data = dem_tbl,\n    aes(x, y, fill = elevation)\n  ) +\n  scale_fill_gradientn(\n    colours = whitebox.colors(20),\n    guide   = guide_colourbar(\n      title          = \"Elevation (m)\",\n      title.hjust    = .5,\n      position       = \"inside\",\n      barwidth       = unit(4, \"mm\"),\n      barheight      = unit(4, \"cm\")\n    )\n  ) +\n  new_scale_fill() +\n  stat_density_2d(\n    aes(x = x, y = y, fill = after_stat(level)), \n    geom = \"polygon\", \n    alpha = .1,\n    bins = 25,\n    show.legend = FALSE\n  ) +\n  geom_point(\n    aes(x, y),\n    alpha = .3\n  ) +\n  scale_fill_gradientn(\n    colours = c(\"darkblue\", \"blue\", \"green\", \"yellow\", \"red\"),\n    # colours = pal\n  ) +\n  labs(\n    title   = \"Where are wolves seen the most in the Iberian Peninsula?\",\n    caption = \"Author: Adrián Cidre | Data source: GBIF (2013-2024)\"\n  ) +\n  theme_void(\n    base_size = 10\n  ) +\n  theme(\n    text = element_text(color = \"snow\"),\n    plot.title = element_text(\n      family = \"Merriweather\",\n      face   = \"bold\",\n      size   = 12,\n      hjust  = .5\n    ),\n    plot.caption = element_text(\n      hjust = .5\n    ),\n    legend.position.inside = c(.85, .3)\n  )\n## Visualize\nmap\n```\n\n::: {.cell-output-display}\n![Density map of the distribution of the gray wolf](index_files/figure-html/fig-density2d-1.png){#fig-density2d width=672}\n:::\n:::\n\n\n\n### 3D visualization\n\nThe `{rayshader}` package has a convenient function to transform a `{ggplot2}` object to a 3D graph. To maintain the dimensions of the Iberian Peninsula, we create two variables with the number of rows and columns of the DEM.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Dimensions of the DEM\nh <- nrow(dem_sr) \nw <- ncol(dem_sr) \n## Print\nprint(h)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1142\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(w)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1492\n```\n\n\n:::\n:::\n\n\n\nNow, we are ready to transform our map to 3D:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_gg(\n  ggobj  = map,\n  width  = w / 200,\n  height = h / 200,\n  scale  = 50,\n  solid  = FALSE,\n  zoom   = .8,\n  phi    = 85,\n  theta  = 0,\n  shadow = FALSE\n)\n```\n:::\n\n\n\nWhat this function does is to create a map with the specified with and height in inches, and the scale factor to create the 3D effect. It will open an `rgl` window that looks like @fig-plotgg.\n\n![Result of plot_gg function](figs/plot3d.png){#fig-plotgg fig-align=\"center\"}\n\nThe final step is to render and export the map in high quality:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrender_highquality(\n  filename          = \"07_wolf_density/wolf_density.png\",\n  width             = w,\n  height            = h,\n  preview           = TRUE,\n  light             = TRUE,\n  environment_light = \"data/env_lights/misty_farm_road_4k.hdr\",\n  intensity_env     = 1,\n  interactive       = FALSE\n)\n```\n:::\n\n\n\nDuring the rendering you will see @fig-renderhighquality. At the top of the figure there's a red loading bar that shows you how the rendering process is going.\n\n![Rendering window of render_highquality](figs/render_highquality.png){#fig-renderhighquality fig-align=\"center\"}\n\n::: callout-caution\nSometimes this rendering function will give weird rendering results. This might be happening because we are using more than 1 fill aesthetic, and it might produce some errors.\n\nIt is not recommended to create 3D maps with more than 1 fill aesthetic, although I can also work as we can see in this example.\n:::\n\nAfter some minutes, we can see the final result:\n\n![Wolf density map in Iberia](figs/wolf_density.png){#fig-final-map fig-align=\"center\"}\n\n## References {.unnumbered}\n\n::: {#refs}\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}