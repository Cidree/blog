{
  "hash": "2a5c374eb9d0c6d6dc817c901a7c4525",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"3D Population Spikes Map - Norway\"\ndate: \"2024-01-07\"\ncategories: [R, rayshader, spatial]\nimage: \"image.png\"\nexecute: \n  warning: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n## Introduction\n\nIn this post, we will create an amazing spikes population map for the country of Norway using the awesome `rayshader` R package.\n\nI will use data from the [Kontur database](https://www.kontur.io/), which has a [population density dataset](https://www.kontur.io/portfolio/population-dataset/) where the world population is represented by H3 hexagons with a spatial resolution of 400 meters.\n\n## Loading packages\n\nIf you followed me in other posts or did any of my [courses](https://adrian-cidre.com/courses), you will notice that I always use the `pacman` package to load the rest of the packages. This is because the `p_load` function will install any missing packages, and then load them into our R session.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pacman)\n\np_load(\n  ## Core\n  tidyverse,\n  \n  ## Donwload data\n  httr, R.utils,\n  \n  ## Spatial data\n  sf, stars, terra,\n  \n  ## Visualization\n  rayshader, colorspace, MetBrewer\n)\n```\n:::\n\n\n## Load the data\n\nThe data can be directly downloaded from the [Kontur website](https://data.humdata.org/organization/kontur), or we can also copy the url for the country and download it into R directly.\n\nFirst I create a function that will download the data using `httr::GET()`, then it will unzip the *gz* file with `R.utils::gunzip()`, and finally it will return the file path without the *gz* extension.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_data_httr <- function(url, file_name) {\n  ## Get url\n  httr::GET(\n    url,\n    write_disk(file_name)\n  )\n  ## Unzip the gz file\n  R.utils::gunzip(file_name, remove = TRUE)\n  ## Get the file path\n  gsub(\".gz\", \"\", file_name)\n}\n```\n:::\n\n\nThen, we apply the function by providing the url to the compressed file, and also the file name with the *gz* extension:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Url\nurl <- \"https://geodata-eu-central-1-kontur-public.s3.amazonaws.com/kontur_datasets/kontur_population_NO_20231101.gpkg.gz\"\n## File name\nfile_name <- \"norway-population.gpkg.gz\"\n\n## Get file path\nfile_path <- get_data_httr(url, file_name)\n```\n:::\n\n\nOnce we downloaded the data, we can read it into R and project it to the Lambert Azimuthal Equal-Area (LAEA) projection:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation_sf <- \n  read_sf(file_path) %>% \n  st_transform(\"EPSG:3035\")\n\npopulation_sf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 186254 features and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 3629718 ymin: 3876026 xmax: 5132823 ymax: 6391949\nProjected CRS: ETRS89-extended / LAEA Europe\n# A tibble: 186,254 × 3\n   h3              population                                               geom\n * <chr>                <dbl>                                      <POLYGON [m]>\n 1 8809abd9b5fffff          2 ((4045387 4292797, 4044957 4292776, 4044823 42923…\n 2 8809abd9a7fffff          1 ((4044985 4291569, 4044555 4291547, 4044421 42911…\n 3 8809abcf67fffff         66 ((4054799 4300908, 4054370 4300887, 4054237 43004…\n 4 8809abcf63fffff          1 ((4054637 4301704, 4054208 4301684, 4054075 43012…\n 5 8809abcf2dfffff          2 ((4055524 4300541, 4055095 4300520, 4054961 43001…\n 6 8809abcf2bfffff          6 ((4055924 4301767, 4055495 4301746, 4055362 43013…\n 7 8809abcf29fffff          6 ((4055362 4301337, 4054933 4301317, 4054799 43009…\n 8 8809abcf27fffff          5 ((4056811 4300603, 4056382 4300583, 4056248 43001…\n 9 8809abcf25fffff          2 ((4056248 4300174, 4055819 4300153, 4055686 42997…\n10 8809abcf21fffff          7 ((4056086 4300970, 4055657 4300950, 4055524 43005…\n# ℹ 186,244 more rows\n```\n\n\n:::\n:::\n\n\nThe data contains the *h3* column which is the ID of the h3 hexagon, and the total *population* within the hexagon.\n\n\n::: {.cell}\n\n:::\n\n\n## Prepare the data\n\nOnce we have the population file loaded into R, we need to convert it into a raster. This is because when working with `rayshader` we need to work with a matrix, and in essence, a raster is a matrix of values.\n\nTherefore, to create the hexagons into a raster, first we need to know the dimensions that we want for our raster. The next function will do the work. First, we get the height and width of the bounding box of our population data. Then we create the ratio variables storing the highest one as 1, and the lowest one as the ratio with the highest:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create function to get width and height\nget_raster_size <- function(bbox) {\n  ## Get height and width in CRS units\n  height <- as.vector(bbox[4] - bbox[2])\n  width  <- as.vector(bbox[3] - bbox[1])\n  ## Get the ratio between height and width\n  if (height > width) {\n    height_ratio <- 1\n    width_ratio <- width / height\n  } else {\n    width_ratio <- 1\n    height_ratio <- height / width\n  }\n  \n  return(list(\n    width  = width_ratio, \n    height = height_ratio)\n  )\n}\n# Get height and width for my data\nhw_ratio <- get_raster_size(st_bbox(population_sf))\n\n# Prin it\nhw_ratio\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$width\n[1] 0.597437\n\n$height\n[1] 1\n```\n\n\n:::\n:::\n\n\nThere we see that Norway's width is about 60% of its height. The next step is to choose the size of the highest dimension (in this case the height). For this example, I chose a size of 2,000 of height which corresponds to 1,194 in width. To clarify, this will determine the number of pixels, and therefore, the spatial resolution. We can then use the `stars::st_rasterize()` function to convert our population file into a raster with the specified size.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsize <- 6000\n\npopulation_stars <- population_sf %>% \n  select(population) %>% \n  st_rasterize(\n    nx = floor(size * hw_ratio$width),\n    ny = floor(size * hw_ratio$height)\n  )\n```\n:::\n\n\n::: callout-tip\nWhen testing I recommend you to use smaller values of size (e.g. 1,000) than when creating the final map (e.g. \\>5,000)\n:::\n\nThe last step before starting to work with `rayshader` is to convert the `stars` object into a matrix. We have the convenient `raster_to_matrix()` function, but it expects a `SpatRaster` or `RasterLayer` as input, so I converted it into a `SpatRaster` prior to converting it into a matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation_matrix <- \n  population_stars %>% \n  rast() %>% \n  raster_to_matrix()\n```\n:::\n\n\n## 3D Visualization\n\nWe can finally create our amazing visualization! Let's define a colour palette first. I will use one that is already in the `MetBrewer` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Define palette\npal <- met.brewer(\"OKeeffe2\", n = 10, \"continuous\")\n## Define texture\npopulation_texture <- colorRampPalette(\n  colors = pal\n)(256)\n## Visualize it\nswatchplot(population_texture)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nTo create a 3D visualization with `rayshader`, the process involves three key steps:\n\n-   Create a base 3D plot (moderate time-consuming)\n\n-   Readjust some parameters (fast)\n\n-   Render our final image with high quality (very time consuming)\n\n### Base 3D plot\n\nThe first image that we will create takes about 3 minutes to render in my laptop with size = 6000. We will use two functions:\n\n-   `height_shade()`: it calculates a colour for each pixel of the raster by using the texture that we defined previously.\n\n-   `plot_3d()`: uses the result of the `height_shade()` function to display a 3D map in a RGL window. The most important arguments are:\n\n    -   Zscale: probably the most important. It's the ratio between the x and y spacing and the z axis. A lower number will create taller spikes, and it's dependent of the resolution (the size we specified to create the raster).\n\n    -   Phi: the azimuth angle in degrees (can be tweaked later).\n\n    -   Theta: rotation around the z-axis in degrees (can be tweaked later).\n\n    -   Zoom: the zoom factor from 0 to 1 (can be tweaked later).\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation_matrix %>% \n  height_shade(texture = population_texture) %>% \n  plot_3d(\n    heightmap       = population_matrix,\n    solid           = FALSE, \n    soliddepth      = 0,      \n    zscale          = 50,\n    shadowdepth     = 0,      \n    shadow_darkness = .95,    \n    windowsize      = c(600, 600),\n    zoom            = .6,   \n    phi             = 50,    \n    theta           = 30,   \n    background      = \"white\"\n  )\n```\n:::\n\n\nThe result appear in a RGL device and looks like @fig-pop-plot. Nothing amazing so far. This is just an interactive device where we can explore our plot.\n\n![Result of plot_3d](figs/01_render.png){#fig-pop-plot fig-align=\"center\"}\n\n### Render camera\n\nWhen we have our plot rendered, we can play with the zoom, theta and phi angles by using the `render_camera` function. This is very convenient because we don't have to render the plot again, and it will be very fast:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrender_camera(\n  zoom  = 0.35,\n  theta = 10,\n  phi   = 15\n)\n```\n:::\n\n\nAfter playing for a while with the values I decided to keep these values as my final choice, which correspond to the @fig-pop-camera.\n\n![Result of render_camera](figs/02_render.png){#fig-pop-camera fig-align=\"center\"}\n\n### Render in high quality\n\nWhen we have our RGL device with our desired map, we can render it to a high quality image.\n\n::: callout-note\nThis is very computational expensive, and depending on the specifications of your machine this process may fail for higher resolutions\n:::\n\nNote that for a size of 2,000 it takes around 5 minutes to run in my computer. However, with a size of 6,000 it takes over 30 minutes. Here I use the function `render_quality()` with the following arguments:\n\n-   Preview: whether or not to preview how the object is rendered (it gives a hint of the remaining time to finish).\n\n-   Lightdirection: angle(s) of direction from where the sun is lightening our map.\n\n-   Lightaltitude: angle(s) of altitude of the sun from the horizontal surface.\n\n-   Lightintensity: intensity of the light(s).\n\n-   Lightcolour: colour of the light(s).\n\n-   Interactive: whether the scene will be interactive.\n\n-   Width and height: defines the resolution of the resulting image.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrayshader::render_highquality(\n  filename       = \"norway_spikes_map.png\",\n  preview        = TRUE,\n  light          = TRUE,\n  lightdirection = c(240, 320),\n  lightaltitude  = c(20, 80), \n  lightintensity = c(600, 100),\n  lightcolor     = c(lighten(pal[7], 0.75), \"white\"),\n  interactive    = FALSE,\n  width          = dim(population_stars)[1], \n  height         = dim(population_stars)[2]\n)\n```\n:::\n\n\nThe resulting image (using a size of 6,000 and zscale of 20) is shown in @fig-spikes-map.\n\n![Spikes population map of Norway](figs/norway_crop.png){#fig-spikes-map fig-align=\"center\"}\n\nWe can see that most of the population of Norway in the half south of the country, specially in Viken region. We can also add some labels to the map, so we get the final result in @fig-spikes-map-labelled.\n\n![Population spikes map of Norway with labels of some important cities](figs/norway_complete.png){#fig-spikes-map-labelled fig-align=\"center\"}\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}